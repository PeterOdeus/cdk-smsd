From 121361e2a80ec74a918eaae62eb9ed9798a5b731 Mon Sep 17 00:00:00 2001
From: Rajarshi  Guha <rajarshi.guha@gmail.com>
Date: Fri, 13 Nov 2009 07:32:19 -0500
Subject: [PATCH 1/3] Converted the use of EBIException to CDKException

---
 .../openscience/cdk/smsd/SubStructureFactory.java  |   35 +++---
 .../openscience/cdk/smsd/algorithm/cdk/CDKMCS.java |  113 ++++++++++----------
 .../cdk/smsd/algorithm/cdk/CDKMCSHandler.java      |   12 +-
 .../cdk/smsd/algorithm/cdk/CDKRGraph.java          |   46 ++++----
 .../cdk/smsd/algorithm/cdk/CDKRMapHandler.java     |   10 +-
 .../cdk/smsd/algorithm/mcsplus/MCSPlus.java        |   12 +-
 .../cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java |    4 +-
 .../cdk/smsd/algorithm/single/SingleMapping.java   |    4 +-
 .../algorithm/single/SingleMappingHandler.java     |    4 +-
 .../cdk/smsd/algorithm/vflib/VFlibHandler.java     |    6 +-
 .../cdk/smsd/algorithm/vflib/VFlibMCSHandler.java  |   10 +-
 .../smsd/algorithm/vflib/VFlibTurboHandler.java    |    6 +-
 .../cdk/smsd/core/tools/EBIBondEnergies.java       |    4 +-
 .../cdk/smsd/core/tools/EBIException.java          |   12 +-
 .../cdk/smsd/core/tools/MoleculeSanityCheck.java   |    2 +-
 .../openscience/cdk/smsd/factory/MCSFactory.java   |   18 ++--
 .../cdk/smsd/factory/SubGraphFactory.java          |   10 +-
 .../cdk/smsd/filters/ChemicalFilters.java          |    6 +-
 .../cdk/smsd/filters/FragmentMatcher.java          |    8 +-
 .../org/openscience/cdk/smsd/interfaces/IMCS.java  |    6 +-
 .../cdk/smsd/interfaces/IMCSAlgorithm.java         |   26 +++---
 .../openscience/cdk/smsd/interfaces/ISubGraph.java |    6 +-
 22 files changed, 181 insertions(+), 179 deletions(-)

diff --git a/src/main/org/openscience/cdk/smsd/SubStructureFactory.java b/src/main/org/openscience/cdk/smsd/SubStructureFactory.java
index 018ac36..5d93da9 100644
--- a/src/main/org/openscience/cdk/smsd/SubStructureFactory.java
+++ b/src/main/org/openscience/cdk/smsd/SubStructureFactory.java
@@ -22,18 +22,19 @@
  */
 package org.openscience.cdk.smsd;
 
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeMap;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.interfaces.IAtom;
+import org.openscience.cdk.interfaces.IAtomContainer;
+import org.openscience.cdk.interfaces.IMolecule;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.factory.MCSFactory;
 import org.openscience.cdk.smsd.factory.SubGraphFactory;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.smsd.interfaces.IMCSAlgorithm;
-import org.openscience.cdk.interfaces.IAtom;
-import org.openscience.cdk.interfaces.IAtomContainer;
-import org.openscience.cdk.interfaces.IMolecule;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
 
 /**
  * @cdk.module smsd
@@ -94,16 +95,16 @@ public class SubStructureFactory implements IMCSAlgorithm {
      * 
      * @param Query
      * @param Target
-     * @throws EBIException 
+     * @throws CDKException
      * 
      */
     @Override
-    public void init(MolHandler Query, MolHandler Target) throws EBIException {
+    public void init(MolHandler Query, MolHandler Target) throws CDKException {
 
         if (Query.getMolecule().getAtomCount() > 0 && Target.getMolecule().getAtomCount() > 0) {
             comparison.init(Query, Target);
         } else {
-            throw new EBIException("Each molecule should have atleast one atom to compare");
+            throw new CDKException("Each molecule should have atleast one atom to compare");
         }
 
         System.gc();
@@ -114,15 +115,15 @@ public class SubStructureFactory implements IMCSAlgorithm {
      * 
      * @param Query
      * @param Target
-     * @throws EBIException 
+     * @throws CDKException
      */
     @Override
-    public synchronized void init(IMolecule Query, IMolecule Target) throws EBIException {
+    public synchronized void init(IMolecule Query, IMolecule Target) throws CDKException {
 
         if (Query.getAtomCount() > 0 && Target.getAtomCount() > 0) {
             comparison.init(Query, Target);
         } else {
-            throw new EBIException("Each molecule should have atleast one atom to compare");
+            throw new CDKException("Each molecule should have atleast one atom to compare");
         }
 
         System.gc();
@@ -132,15 +133,15 @@ public class SubStructureFactory implements IMCSAlgorithm {
      * 
      * @param Query
      * @param Target
-     * @throws EBIException 
+     * @throws CDKException 
      */
     @Override
-    public synchronized void init(IAtomContainer Query, IAtomContainer Target) throws EBIException {
+    public synchronized void init(IAtomContainer Query, IAtomContainer Target) throws CDKException {
 
         if (Query.getAtomCount() > 0 && Target.getAtomCount() > 0) {
             comparison.init(Query, Target);
         } else {
-            throw new EBIException("Each molecule should have atleast one atom to compare");
+            throw new CDKException("Each molecule should have atleast one atom to compare");
         }
 
         System.gc();
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKMCS.java b/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKMCS.java
index e1cf9f8..67a3399 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKMCS.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKMCS.java
@@ -54,16 +54,6 @@
 package org.openscience.cdk.smsd.algorithm.cdk;
 
 
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import org.openscience.cdk.smsd.core.tools.EBIException;
-import org.openscience.cdk.smsd.core.tools.EBITimeManager;
-import org.openscience.cdk.smsd.global.BondType;
-import org.openscience.cdk.smsd.global.TimeOut;
 import org.openscience.cdk.CDKConstants;
 import org.openscience.cdk.interfaces.IAtom;
 import org.openscience.cdk.interfaces.IAtomContainer;
@@ -71,8 +61,19 @@ import org.openscience.cdk.interfaces.IBond;
 import org.openscience.cdk.isomorphism.matchers.IQueryAtom;
 import org.openscience.cdk.isomorphism.matchers.IQueryAtomContainer;
 import org.openscience.cdk.isomorphism.matchers.IQueryBond;
+import org.openscience.cdk.smsd.core.tools.CDKException;
+import org.openscience.cdk.smsd.core.tools.EBITimeManager;
+import org.openscience.cdk.smsd.global.BondType;
+import org.openscience.cdk.smsd.global.TimeOut;
 import org.openscience.cdk.tools.manipulator.BondManipulator;
 
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
 /**
  *  This class implements a multipurpose structure comparison tool.
  *  It allows to find maximal common substructure, find the
@@ -160,12 +161,12 @@ public class CDKMCS {
      * @param  g1  first molecule. Must not be an IQueryAtomContainer.
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     true if the 2 molecule are isomorph
-     * @throws EBIException if the first molecule is an instance
+     * @throws CDKException if the first molecule is an instance
      * of IQueryAtomContainer
      */
-    public static boolean isIsomorph(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static boolean isIsomorph(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         if (g1 instanceof IQueryAtomContainer) {
-            throw new EBIException("The first IAtomContainer must not be an IQueryAtomContainer");
+            throw new CDKException("The first IAtomContainer must not be an IQueryAtomContainer");
         }
 
         if (g2.getAtomCount() != g1.getAtomCount()) {
@@ -195,11 +196,11 @@ public class CDKMCS {
      * @param  g1  first molecule. Must not be an IQueryAtomContainer.
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     the first isomorph mapping found projected of g1. This is a List of CDKRMap objects containing Ids of matching bonds.
-     * @throws EBIException
+     * @throws CDKException
      */
-    public static List<CDKRMap> getIsomorphMap(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<CDKRMap> getIsomorphMap(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         if (g1 instanceof IQueryAtomContainer) {
-            throw new EBIException("The first IAtomContainer must not be an IQueryAtomContainer");
+            throw new CDKException("The first IAtomContainer must not be an IQueryAtomContainer");
         }
 
         List<CDKRMap> result = null;
@@ -220,12 +221,12 @@ public class CDKMCS {
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     the first isomorph atom mapping found projected on g1.
      * This is a List of CDKRMap objects containing Ids of matching atoms.
-     * @throws EBIException if the first molecules is not an instance of
+     * @throws CDKException if the first molecules is not an instance of
      *  {@link org.openscience.cdk.isomorphism.matchers.IQueryAtomContainer}
      */
-    public static List<CDKRMap> getIsomorphAtomsMap(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<CDKRMap> getIsomorphAtomsMap(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         if (g1 instanceof IQueryAtomContainer) {
-            throw new EBIException("The first IAtomContainer must not be an IQueryAtomContainer");
+            throw new CDKException("The first IAtomContainer must not be an IQueryAtomContainer");
         }
 
         List<CDKRMap> list = checkSingleAtomCases(g1, g2);
@@ -245,9 +246,9 @@ public class CDKMCS {
      * @param  g1  first molecule. Must not be an IQueryAtomContainer.
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     the list of all the 'mappings'
-     * @throws EBIException
+     * @throws CDKException
      */
-    public static List<List<CDKRMap>> getIsomorphMaps(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<List<CDKRMap>> getIsomorphMaps(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         return search(g1, g2, getBitSet(g1), getBitSet(g2), true, true);
     }
 
@@ -260,9 +261,9 @@ public class CDKMCS {
      * @param  g1  first molecule. Must not be an IQueryAtomContainer.
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     the list of all the 'mappings' found projected of g1
-     * @throws EBIException
+     * @throws CDKException
      */
-    public static List<List<CDKRMap>> getSubgraphMaps(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<List<CDKRMap>> getSubgraphMaps(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         return search(g1, g2, new BitSet(), getBitSet(g2), true, true);
     }
 
@@ -272,9 +273,9 @@ public class CDKMCS {
      * @param  g1  first molecule. Must not be an IQueryAtomContainer.
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     the first subgraph bond mapping found projected on g1. This is a List of CDKRMap objects containing Ids of matching bonds.
-     * @throws EBIException
+     * @throws CDKException
      */
-    public static List<CDKRMap> getSubgraphMap(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<CDKRMap> getSubgraphMap(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         List<CDKRMap> result = null;
         List<List<CDKRMap>> rMapsList = search(g1, g2, new BitSet(), getBitSet(g2), false, false);
 
@@ -292,10 +293,10 @@ public class CDKMCS {
      * @param  g1  first molecule. Must not be an IQueryAtomContainer.
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     all subgraph atom mappings found projected on g1. This is a List of CDKRMap objects containing Ids of matching atoms.
-     * @throws EBIException
+     * @throws CDKException
      */
     //Fixed by Asad
-    public static List<List<CDKRMap>> getSubgraphAtomsMaps(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<List<CDKRMap>> getSubgraphAtomsMaps(IAtomContainer g1, IAtomContainer g2) throws CDKException {
 
         List<List<CDKRMap>> l = new ArrayList<List<CDKRMap>>();
 
@@ -326,10 +327,10 @@ public class CDKMCS {
      * @param  g1  first molecule. Must not be an IQueryAtomContainer.
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     the first subgraph atom mapping found projected on g1. This is a List of CDKRMap objects containing Ids of matching atoms.
-     * @throws EBIException
+     * @throws CDKException
      */
     //Fixed by Asad
-    public static List<CDKRMap> getSubgraphAtomsMap(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<CDKRMap> getSubgraphAtomsMap(IAtomContainer g1, IAtomContainer g2) throws CDKException {
 
         List<CDKRMap> l = new ArrayList<CDKRMap>();
         List<CDKRMap> list = checkSingleAtomCases(g1, g2);
@@ -357,11 +358,11 @@ public class CDKMCS {
      * @param  g1  first molecule. Must not be an IQueryAtomContainer.
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     true if g2 a subgraph on g1
-     * @throws EBIException
+     * @throws CDKException
      */
-    public static boolean isSubgraph(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static boolean isSubgraph(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         if (g1 instanceof IQueryAtomContainer) {
-            throw new EBIException("The first IAtomContainer must not be an IQueryAtomContainer");
+            throw new CDKException("The first IAtomContainer must not be an IQueryAtomContainer");
         }
 
         if (g2.getAtomCount() > g1.getAtomCount()) {
@@ -405,9 +406,9 @@ public class CDKMCS {
      * @param  g2  second molecule. May be an IQueryAtomContainer.
      * @return     the list of all the maximal common substructure
      *             found projected of g1 (list of AtomContainer )
-     * @throws EBIException
+     * @throws CDKException
      */
-    public static List<IAtomContainer> getOverlaps(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<IAtomContainer> getOverlaps(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         List<List<CDKRMap>> rMapsList = search(g1, g2, new BitSet(), new BitSet(), true, false);
 
         // projection on G1
@@ -453,9 +454,9 @@ public class CDKMCS {
      * @param  g1  Description of the first molecule
      * @param  g2  Description of the second molecule
      * @return     the rGraph
-     * @throws EBIException
+     * @throws CDKException
      */
-    public static CDKRGraph buildRGraph(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static CDKRGraph buildRGraph(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         CDKRGraph rGraph = new CDKRGraph();
         nodeConstructor(rGraph, g1, g2);
         arcConstructor(rGraph, g1, g2);
@@ -477,10 +478,10 @@ public class CDKMCS {
      * @param  findAllMap        if true search all the 'mappings' for one same
      *                           structure
      * @return                   a List of Lists of CDKRMap objects that represent the search solutions
-     * @throws EBIException
+     * @throws CDKException
      */
     public static List<List<CDKRMap>> search(IAtomContainer g1, IAtomContainer g2, BitSet c1,
-            BitSet c2, boolean findAllStructure, boolean findAllMap) throws EBIException {
+            BitSet c2, boolean findAllStructure, boolean findAllMap) throws CDKException {
 
         // reset result
         List<List<CDKRMap>> rMapsList = new ArrayList<List<CDKRMap>>();
@@ -492,7 +493,7 @@ public class CDKMCS {
             //System.out.println("|Hello|");
             timeoutFlag = true;
 
-            throw new EBIException("Timeout exceeded in getOverlaps");
+            throw new CDKException("Timeout exceeded in getOverlaps");
         }
 
 
@@ -502,7 +503,7 @@ public class CDKMCS {
             //System.out.println("|Hello|");
             timeoutFlag = true;
 
-            throw new EBIException("Timeout exceeded in getOverlaps");
+            throw new CDKException("Timeout exceeded in getOverlaps");
         }
         // parse the CDKRGraph with the given constrains and options
         rGraph.parse(c1, c2, findAllStructure, findAllMap, TM);
@@ -514,7 +515,7 @@ public class CDKMCS {
                 //System.out.println("|Hello|");
                 timeoutFlag = true;
 
-                throw new EBIException("Timeout exceeded in getOverlaps");
+                throw new CDKException("Timeout exceeded in getOverlaps");
             }
             rMapsList.add(rGraph.bitSetToRMap(set));
         }
@@ -607,10 +608,10 @@ public class CDKMCS {
      *
      * @param  graphList  the list of structure to clean
      * @return            the list cleaned
-     * @throws org.openscience.cdk.exception.EBIException if there is a problem in obtaining
+     * @throws org.openscience.cdk.exception.CDKException if there is a problem in obtaining
      * subgraphs
      */
-    private static List<IAtomContainer> getMaximum(ArrayList<IAtomContainer> graphList) throws EBIException {
+    private static List<IAtomContainer> getMaximum(ArrayList<IAtomContainer> graphList) throws CDKException {
         @SuppressWarnings("unchecked")
         List<IAtomContainer> reducedGraphList = (List<IAtomContainer>) graphList.clone();
 
@@ -638,12 +639,12 @@ public class CDKMCS {
      * @param  g1  AtomContainer to match on. Must not be an IQueryAtomContainer.
      * @param  g2  AtomContainer as query. May be an IQueryAtomContainer.
      * @return     List of List of CDKRMap objects for the Atoms (not Bonds!), null if no single atom case
-     * @throws EBIException if the first molecule is an instance
+     * @throws CDKException if the first molecule is an instance
      * of IQueryAtomContainer
      */
-    public static List<CDKRMap> checkSingleAtomCases(IAtomContainer g1, IAtomContainer g2) throws EBIException {
+    public static List<CDKRMap> checkSingleAtomCases(IAtomContainer g1, IAtomContainer g2) throws CDKException {
         if (g1 instanceof IQueryAtomContainer) {
-            throw new EBIException(
+            throw new CDKException(
                     "The first IAtomContainer must not be an IQueryAtomContainer");
         }
 
@@ -773,11 +774,11 @@ public class CDKMCS {
      * @param  gr   the target CDKRGraph
      * @param  ac1   first molecule. Must not be an IQueryAtomContainer.
      * @param  ac2   second molecule. May be an IQueryAtomContainer.
-     * @throws org.openscience.cdk.exception.EBIException if it takes too long to identify overlaps
+     * @throws org.openscience.cdk.exception.CDKException if it takes too long to identify overlaps
      */
-    private static void nodeConstructor(CDKRGraph gr, IAtomContainer ac1, IAtomContainer ac2) throws EBIException {
+    private static void nodeConstructor(CDKRGraph gr, IAtomContainer ac1, IAtomContainer ac2) throws CDKException {
         if (ac1 instanceof IQueryAtomContainer) {
-            throw new EBIException(
+            throw new CDKException(
                     "The first IAtomContainer must not be an IQueryAtomContainer");
         }
 
@@ -791,7 +792,7 @@ public class CDKMCS {
                     //System.out.println("|Hello|");
                     timeoutFlag = true;
 
-                    throw new EBIException("Timeout exceeded in getOverlaps");
+                    throw new CDKException("Timeout exceeded in getOverlaps");
                 }
                 IBond bondA2 = ac2.getBond(j);
                 if (bondA2 instanceof IQueryBond) {
@@ -873,9 +874,9 @@ public class CDKMCS {
      * @param  gr   the rGraph
      * @param  ac1   first molecule. Must not be an IQueryAtomContainer.
      * @param  ac2   second molecule. May be an IQueryAtomContainer.
-     * @throws org.openscience.cdk.exception.EBIException if it takes too long to get the overlaps
+     * @throws org.openscience.cdk.exception.CDKException if it takes too long to get the overlaps
      */
-    private static void arcConstructor(CDKRGraph gr, IAtomContainer ac1, IAtomContainer ac2) throws EBIException {
+    private static void arcConstructor(CDKRGraph gr, IAtomContainer ac1, IAtomContainer ac2) throws CDKException {
         // each node is incompatible with himself
         for (int i = 0; i < gr.getGraph().size(); i++) {
             CDKRNode x = gr.getGraph().get(i);
@@ -901,7 +902,7 @@ public class CDKMCS {
                     //System.out.println("|Hello|");
                     timeoutFlag = true;
 
-                    throw new EBIException("Timeout exceeded in getOverlaps");
+                    throw new CDKException("Timeout exceeded in getOverlaps");
                 }
                 CDKRNode y = gr.getGraph().get(j);
 
@@ -1052,13 +1053,13 @@ public class CDKMCS {
      * @param  ac1  the supergraph to be checked. Must not be an IQueryAtomContainer.
      * @param  ac2  the subgraph to be tested for. May be an IQueryAtomContainer.
      * @return    true if the subgraph ac2 has a chance to be a subgraph of ac1
-     * @throws org.openscience.cdk.exception.EBIException if the first molecule is an instance
+     * @throws org.openscience.cdk.exception.CDKException if the first molecule is an instance
      * of IQueryAtomContainer
      */
     private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2)
-            throws EBIException {
+            throws CDKException {
         if (ac1 instanceof IQueryAtomContainer) {
-            throw new EBIException(
+            throw new CDKException(
                     "The first IAtomContainer must not be an IQueryAtomContainer");
         }
 
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKMCSHandler.java b/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKMCSHandler.java
index 8d296f4..095d4ec 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKMCSHandler.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKMCSHandler.java
@@ -29,7 +29,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
 import java.util.Vector;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.FinalMappings;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.smsd.interfaces.IMCS;
@@ -135,7 +135,7 @@ public class CDKMCSHandler implements IMCS {
      * @return
      */
     @Override
-    public int search_MCS(boolean removeHydrogen) throws EBIException {
+    public int search_MCS(boolean removeHydrogen) throws CDKException {
 
 
         CDKRMapHandler rmap = new CDKRMapHandler();
@@ -166,7 +166,7 @@ public class CDKMCSHandler implements IMCS {
             setFirstMapping();
             setFirstAtomMapping();
 
-        } catch (EBIException e) {
+        } catch (CDKException e) {
             rmap = null;
 //            System.err.println("WARNING: CDKMCS: most probably time out error ");
         }
@@ -180,7 +180,7 @@ public class CDKMCSHandler implements IMCS {
      * @param ac2
      * 
      */
-    private IAtomContainer CalculateMCSS(IAtomContainer ac1, IAtomContainer ac2) throws EBIException {
+    private IAtomContainer CalculateMCSS(IAtomContainer ac1, IAtomContainer ac2) throws CDKException {
 
 
 
@@ -205,9 +205,9 @@ public class CDKMCSHandler implements IMCS {
      * @param mol
      * @param mcss
      * @return
-     * @throws EBIException 
+     * @throws CDKException
      */
-    protected IMoleculeSet getUncommon(IAtomContainer mol, IAtomContainer mcss) throws EBIException {
+    protected IMoleculeSet getUncommon(IAtomContainer mol, IAtomContainer mcss) throws CDKException {
         ArrayList<Integer> atomSerialsToDelete = new ArrayList<Integer>();
 
         List matches = CDKMCS.getSubgraphAtomsMaps(mol, mcss);
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKRGraph.java b/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKRGraph.java
index 338392e..6a9b1bf 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKRGraph.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKRGraph.java
@@ -35,7 +35,7 @@ import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Iterator;
 import java.util.List;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.core.tools.EBITimeManager;
 import org.openscience.cdk.smsd.global.TimeOut;
 
@@ -214,14 +214,14 @@ public class CDKRGraph {
      * @param  findAllStructure true if we want all results to be generated
      * @param  findAllMap true is we want all possible 'mappings'
      * @param TM
-     * @throws EBIException
+     * @throws CDKException
      */
-    public void parse(BitSet c1, BitSet c2, boolean findAllStructure, boolean findAllMap, EBITimeManager TM) throws EBIException {
+    public void parse(BitSet c1, BitSet c2, boolean findAllStructure, boolean findAllMap, EBITimeManager TM) throws CDKException {
         // initialize the list of solution
 
         this.TM = TM;
         if (timeout > -1 && TM.getElapsedTimeInMinutes() > timeout) {
-            throw new EBIException("Timeout exceeded in getOverlaps");
+            throw new CDKException("Timeout exceeded in getOverlaps");
         }
         // initialize the list of solution
         solutionList.clear();
@@ -248,14 +248,14 @@ public class CDKRGraph {
      * @param  extension  possible extension node (allowed neighbors)
      * @param  forbiden   node forbidden (set of node incompatible with the current solution)
      */
-    private void parseRec(BitSet traversed, BitSet extension, BitSet forbidden) throws EBIException {
+    private void parseRec(BitSet traversed, BitSet extension, BitSet forbidden) throws CDKException {
         BitSet newTraversed = null;
         BitSet newExtension = null;
         BitSet newForbidden = null;
         BitSet potentialNode = null;
 
         if (timeout > -1 && TM.getElapsedTimeInMinutes() > timeout) {
-            throw new EBIException("Timeout exceeded in getOverlaps");
+            throw new CDKException("Timeout exceeded in getOverlaps");
         }
 
         // if there is no more extension possible we
@@ -325,7 +325,7 @@ public class CDKRGraph {
      *
      * @param  traversed  new potential solution
      */
-    private void solution(BitSet traversed) throws EBIException {
+    private void solution(BitSet traversed) throws CDKException {
         boolean included = false;
         BitSet projG1 = projectG1(traversed);
         BitSet projG2 = projectG2(traversed);
@@ -342,7 +342,7 @@ public class CDKRGraph {
 
                 if (timeout > -1 && TM.getElapsedTimeInMinutes() > timeout) {
                     //System.out.println("|Hello|");
-                    throw new EBIException("Timeout exceeded in getOverlaps");
+                    throw new CDKException("Timeout exceeded in getOverlaps");
                 }
 
                 if (!sol.equals(traversed)) {
@@ -426,7 +426,7 @@ public class CDKRGraph {
      * @param  c2  constraint in the graph G2
      * @return
      */
-    private BitSet buildB(BitSet c1, BitSet c2) throws EBIException {
+    private BitSet buildB(BitSet c1, BitSet c2) throws CDKException {
         this.c1 = c1;
         this.c2 = c2;
 
@@ -439,7 +439,7 @@ public class CDKRGraph {
 
             if (timeout > -1 && TM.getElapsedTimeInMinutes() > timeout) {
                 //System.out.println("|Hello|");
-                throw new EBIException("Timeout exceeded in getOverlaps");
+                throw new CDKException("Timeout exceeded in getOverlaps");
             }
 
             if ((c1.get(rn.getRMap().id1) || c1.isEmpty()) && (c2.get(rn.getRMap().id2) || c2.isEmpty())) {
@@ -616,7 +616,7 @@ public class CDKRGraph {
 // */
 //package chemlib.ebi.molecule.mcs.algorithm.cdk;
 //
-//import chemlib.ebi.core.tools.EBIException;
+//import chemlib.ebi.core.tools.CDKException;
 //import chemlib.ebi.core.tools.EBITimeManager;
 //import chemlib.ebi.molecule.mcs.global.TimeOut;
 //import java.util.ArrayList;
@@ -797,9 +797,9 @@ public class CDKRGraph {
 //     * @param  findAllStructure true if we want all results to be generated
 //     * @param  findAllMap true is we want all possible 'mappings'
 //     * @param TM
-//     * @throws EBIException
+//     * @throws CDKException
 //     */
-//    public void parse(BitSet c1, BitSet c2, boolean findAllStructure, boolean findAllMap, EBITimeManager TM) throws EBIException {
+//    public void parse(BitSet c1, BitSet c2, boolean findAllStructure, boolean findAllMap, EBITimeManager TM) throws CDKException {
 //        // initialize the list of solution
 //
 //        this.TM = TM;
@@ -808,7 +808,7 @@ public class CDKRGraph {
 //            //System.out.println("|Hello|");
 //
 //
-//            throw new EBIException("Timeout exceeded in getOverlaps");
+//            throw new CDKException("Timeout exceeded in getOverlaps");
 //        }
 //        solutionList.clear();
 //
@@ -829,7 +829,7 @@ public class CDKRGraph {
 //            //System.out.println("|Hello|");
 //
 //
-//            throw new EBIException("Timeout exceeded in getOverlaps");
+//            throw new CDKException("Timeout exceeded in getOverlaps");
 //        }
 //    }
 //
@@ -843,7 +843,7 @@ public class CDKRGraph {
 //     * @param  extension  possible extension node (allowed neighbours)
 //     * @param  forbiden   node forbiden (set of node incompatible with the current solution)
 //     */
-//    private void parseRec(BitSet traversed, BitSet extension, BitSet forbidden) throws EBIException {
+//    private void parseRec(BitSet traversed, BitSet extension, BitSet forbidden) throws CDKException {
 //        BitSet newTraversed = null;
 //        BitSet newExtension = null;
 //        BitSet newForbidden = null;
@@ -855,7 +855,7 @@ public class CDKRGraph {
 //            //System.out.println("|Hello|");
 //
 //
-//            throw new EBIException("Timeout exceeded in getOverlaps");
+//            throw new CDKException("Timeout exceeded in getOverlaps");
 //        }
 //
 //        // if there is no more extension possible we
@@ -929,7 +929,7 @@ public class CDKRGraph {
 //     * @param  traversed  new potential solution
 //     */
 //    @SuppressWarnings("unchecked")
-//    private void solution(BitSet traversed) throws EBIException {
+//    private void solution(BitSet traversed) throws CDKException {
 //        boolean included = false;
 //        BitSet projG1 = projectG1(traversed);
 //        BitSet projG2 = projectG2(traversed);
@@ -948,7 +948,7 @@ public class CDKRGraph {
 //                    //System.out.println("|Hello|");
 //
 //
-//                    throw new EBIException("Timeout exceeded in getOverlaps");
+//                    throw new CDKException("Timeout exceeded in getOverlaps");
 //                }
 //
 //                if (!sol.equals(traversed)) {
@@ -988,7 +988,7 @@ public class CDKRGraph {
 //     * @param       potentialNode  set of remaining potential nodes
 //     * @return      true if it is worse to continue the search
 //     */
-//    private boolean mustContinue(BitSet potentialNode) throws EBIException {
+//    private boolean mustContinue(BitSet potentialNode) throws CDKException {
 //        boolean result = true;
 //        boolean cancel = false;
 //        BitSet projG1 = projectG1(potentialNode);
@@ -1014,7 +1014,7 @@ public class CDKRGraph {
 //                //System.out.println("|Hello|");
 //
 //
-//                throw new EBIException("Timeout exceeded in getOverlaps");
+//                throw new CDKException("Timeout exceeded in getOverlaps");
 //            }
 //
 //            // if we want every 'mappings' do not stop
@@ -1039,7 +1039,7 @@ public class CDKRGraph {
 //     * @param  c2  constraint in the graph G2
 //     * @return
 //     */
-//    private BitSet buildB(BitSet c1, BitSet c2) throws EBIException {
+//    private BitSet buildB(BitSet c1, BitSet c2) throws CDKException {
 //        this.c1 = c1;
 //        this.c2 = c2;
 //
@@ -1053,7 +1053,7 @@ public class CDKRGraph {
 //                //System.out.println("|Hello|");
 //
 //
-//                throw new EBIException("Timeout exceeded in getOverlaps");
+//                throw new CDKException("Timeout exceeded in getOverlaps");
 //            }
 //            CDKRNode rn = (CDKRNode) i.next();
 //
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKRMapHandler.java b/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKRMapHandler.java
index 1e1a49b..81fb93a 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKRMapHandler.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/cdk/CDKRMapHandler.java
@@ -28,7 +28,7 @@ import java.util.List;
 import java.util.Stack;
 import java.util.TreeMap;
 import java.util.Vector;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.FinalMappings;
 import org.openscience.cdk.interfaces.IAtom;
 import org.openscience.cdk.interfaces.IAtomContainer;
@@ -57,9 +57,9 @@ public class CDKRMapHandler {
      * This function calculates all the possible combinations of MCS
      * @param Molecule1
      * @param Molecule2
-     * @throws EBIException
+     * @throws CDKException
      */
-    public void calculateOverlapsAndReduce(IAtomContainer Molecule1, IAtomContainer Molecule2) throws EBIException {
+    public void calculateOverlapsAndReduce(IAtomContainer Molecule1, IAtomContainer Molecule2) throws CDKException {
 
         ac1 = Molecule1;
         ac2 = Molecule2;
@@ -136,9 +136,9 @@ public class CDKRMapHandler {
      * Fingerprint
      * @param Molecule1
      * @param Molecule2
-     * @throws EBIException
+     * @throws CDKException
      */
-    public void calculateOverlapsAndReduceExactMatch(IAtomContainer Molecule1, IAtomContainer Molecule2) throws EBIException {
+    public void calculateOverlapsAndReduceExactMatch(IAtomContainer Molecule1, IAtomContainer Molecule2) throws CDKException {
 
         ac1 = Molecule1;
         ac2 = Molecule2;
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlus.java b/src/main/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlus.java
index 90d4ff8..a89f997 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlus.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlus.java
@@ -29,7 +29,7 @@ import java.util.Vector;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import org.openscience.cdk.smsd.algorithm.mcgregor.McGregor;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.core.tools.EBITimeManager;
 import org.openscience.cdk.smsd.filters.ExactMapping;
 import org.openscience.cdk.smsd.global.TimeOut;
@@ -50,9 +50,9 @@ public class MCSPlus {
      * @param ac2
      * @param removeHydrogen
      * @return
-     * @throws EBIException
+     * @throws CDKException
      */
-    public List<List<Integer>> getOverlaps(IAtomContainer ac1, IAtomContainer ac2, boolean removeHydrogen) throws EBIException {
+    public List<List<Integer>> getOverlaps(IAtomContainer ac1, IAtomContainer ac2, boolean removeHydrogen) throws CDKException {
         Stack<List<Integer>> Max_Cliques_Set = null;
         List<List<Integer>> _mappings = new Vector<List<Integer>>();
 
@@ -86,7 +86,7 @@ public class MCSPlus {
             if (timeout > -1 && TM.getElapsedTimeInMinutes() > timeout) {
                 //System.out.println("|Hello|");
                 timeoutFlag = true;
-                throw new EBIException("Timeout exceeded in getOverlaps");
+                throw new CDKException("Timeout exceeded in getOverlaps");
             }
             BKKCKCF init = new BKKCKCF(comp_graph_nodes, C_edges, D_edges);
 //            BronKerboschKochCliqueFinder init = new BronKerboschKochCliqueFinder(comp_graph_nodes, C_edges, D_edges);
@@ -97,7 +97,7 @@ public class MCSPlus {
             if (timeout > -1 && TM.getElapsedTimeInMinutes() > timeout) {
                 //System.out.println("|Hello|");
                 timeoutFlag = true;
-                throw new EBIException("Timeout exceeded in getOverlaps");
+                throw new CDKException("Timeout exceeded in getOverlaps");
             }
 
 //            int solution_size_pass1 = Max_Cliques_Set.size();
@@ -119,7 +119,7 @@ public class MCSPlus {
                 if (timeout > -1 && TM.getElapsedTimeInMinutes() > timeout) {
                     //System.out.println("|Hello|");
                     timeoutFlag = true;
-                    throw new EBIException("Timeout exceeded in getOverlaps");
+                    throw new CDKException("Timeout exceeded in getOverlaps");
                 }
 
 
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java b/src/main/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java
index 19d7a64..d29a250 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java
@@ -30,7 +30,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
 import java.util.Vector;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.filters.PostFilter;
 import org.openscience.cdk.smsd.helper.FinalMappings;
 import org.openscience.cdk.smsd.helper.MolHandler;
@@ -141,7 +141,7 @@ public class MCSPlusHandler implements IMCS {
             setAllAtomMapping();
             setFirstMapping();
             setFirstAtomMapping();
-        } catch (EBIException e) {
+        } catch (CDKException e) {
             _mappings = null;
 //            System.err.println("WARNING: MCSPlus: most probably time out error ");
         }
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/single/SingleMapping.java b/src/main/org/openscience/cdk/smsd/algorithm/single/SingleMapping.java
index 19489a3..49434c1 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/single/SingleMapping.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/single/SingleMapping.java
@@ -167,8 +167,8 @@ public class SingleMapping {
             System.err.println("skippping Hydrogen mapping");
 //            try {
 //                
-//                throw new EBIException("Hydrogens can't be Mapped");
-//            } catch (EBIException ex) {
+//                throw new CDKException("Hydrogens can't be Mapped");
+//            } catch (CDKException ex) {
 //                Logger.getLogger(SingleMapping.class.getName()).log(Level.SEVERE, null, ex);
 //            }
         }
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/single/SingleMappingHandler.java b/src/main/org/openscience/cdk/smsd/algorithm/single/SingleMappingHandler.java
index 635388a..43a8fd3 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/single/SingleMappingHandler.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/single/SingleMappingHandler.java
@@ -29,7 +29,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
 import java.util.Vector;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.FinalMappings;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.smsd.interfaces.IMCS;
@@ -121,7 +121,7 @@ public class SingleMappingHandler implements IMCS {
      * @throws java.io.IOException
      */
     @Override
-    public int search_MCS(boolean removeHydrogen) throws IOException, EBIException {
+    public int search_MCS(boolean removeHydrogen) throws IOException, CDKException {
 
 
         SingleMapping SM = new SingleMapping();
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibHandler.java b/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibHandler.java
index 9ca46e7..aacfa7c 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibHandler.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibHandler.java
@@ -33,7 +33,7 @@ import org.openscience.cdk.smsd.algorithm.vflib.interfaces.IQuery;
 import org.openscience.cdk.smsd.algorithm.vflib.map.VFMapper;
 import org.openscience.cdk.smsd.algorithm.vflib.query.TemplateCompiler;
 import org.openscience.cdk.smsd.core.tools.EBIAtomContainerManipulator;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.smsd.interfaces.ISubGraph;
 import org.openscience.cdk.interfaces.IAtom;
@@ -66,10 +66,10 @@ public class VFlibHandler implements ISubGraph {
      * @return true if Query/Reactant is a subgraph of Target/Product
      * else false
      * @throws java.io.IOException
-     * @throws chemlib.ebi.core.tools.EBIException
+     * @throws chemlib.ebi.core.tools.CDKException
      */
     @Override
-    public boolean isSubgraph() throws IOException, EBIException {
+    public boolean isSubgraph() throws IOException, CDKException {
 
         IQuery query = TemplateCompiler.compile(Reactant);
 
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibMCSHandler.java b/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibMCSHandler.java
index 64145c0..e82c177 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibMCSHandler.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibMCSHandler.java
@@ -37,7 +37,7 @@ import org.openscience.cdk.smsd.algorithm.vflib.interfaces.INode;
 import org.openscience.cdk.smsd.algorithm.vflib.interfaces.IQuery;
 import org.openscience.cdk.smsd.algorithm.vflib.map.VFMCSMapper;
 import org.openscience.cdk.smsd.algorithm.vflib.query.TemplateCompiler;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.smsd.interfaces.IMCS;
 import org.openscience.cdk.interfaces.IAtom;
@@ -80,7 +80,7 @@ public class VFlibMCSHandler implements IMCS {
      * @throws java.io.IOException
      */
     @Override
-    public int search_MCS(boolean removeHydrogen) throws IOException, EBIException {
+    public int search_MCS(boolean removeHydrogen) throws IOException, CDKException {
 
 
 //        System.out.println("VF Solution Count: " + vfLibSolutions.size());
@@ -139,7 +139,7 @@ public class VFlibMCSHandler implements IMCS {
                         indexindexMapping.put(qIndex, tIndex);
                     } else {
 
-                        throw new EBIException("Atom index pointing to NULL");
+                        throw new CDKException("Atom index pointing to NULL");
                     }
                 }
 
@@ -302,8 +302,8 @@ public class VFlibMCSHandler implements IMCS {
                     indexindexMapping.put(qIndex, tIndex);
                 } else {
                     try {
-                        throw new EBIException("Atom index pointing to NULL");
-                    } catch (EBIException ex) {
+                        throw new CDKException("Atom index pointing to NULL");
+                    } catch (CDKException ex) {
                         Logger.getLogger(VFlibMCSHandler.class.getName()).log(Level.SEVERE, null, ex);
                     }
                 }
diff --git a/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibTurboHandler.java b/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibTurboHandler.java
index 2325218..cde27c8 100644
--- a/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibTurboHandler.java
+++ b/src/main/org/openscience/cdk/smsd/algorithm/vflib/VFlibTurboHandler.java
@@ -33,7 +33,7 @@ import org.openscience.cdk.smsd.algorithm.vflib.interfaces.IQuery;
 import org.openscience.cdk.smsd.algorithm.vflib.map.VFMapper;
 import org.openscience.cdk.smsd.algorithm.vflib.query.TemplateCompiler;
 import org.openscience.cdk.smsd.core.tools.EBIAtomContainerManipulator;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.smsd.interfaces.ISubGraph;
 import org.openscience.cdk.interfaces.IAtom;
@@ -66,10 +66,10 @@ public class VFlibTurboHandler implements ISubGraph {
      * @return true if Query/Reactant is a subgraph of Target/Product
      * else false
      * @throws java.io.IOException
-     * @throws chemlib.ebi.core.tools.EBIException
+     * @throws chemlib.ebi.core.tools.CDKException
      */
     @Override
-    public boolean isSubgraph() throws IOException, EBIException {
+    public boolean isSubgraph() throws IOException, CDKException {
 
         IQuery query = TemplateCompiler.compile(Reactant);
 
diff --git a/src/main/org/openscience/cdk/smsd/core/tools/EBIBondEnergies.java b/src/main/org/openscience/cdk/smsd/core/tools/EBIBondEnergies.java
index 6b1207b..18fc4a4 100644
--- a/src/main/org/openscience/cdk/smsd/core/tools/EBIBondEnergies.java
+++ b/src/main/org/openscience/cdk/smsd/core/tools/EBIBondEnergies.java
@@ -46,10 +46,10 @@ public class EBIBondEnergies {
     /**
      * 
      * @return
-     * @throws EBIException 
+     * @throws CDKException
      */
     public synchronized static EBIBondEnergies getInstance()
-            throws EBIException {
+            throws CDKException {
         if (null == _instance) {
             _instance = new EBIBondEnergies();
         }
diff --git a/src/main/org/openscience/cdk/smsd/core/tools/EBIException.java b/src/main/org/openscience/cdk/smsd/core/tools/EBIException.java
index d4633db..35bf268 100644
--- a/src/main/org/openscience/cdk/smsd/core/tools/EBIException.java
+++ b/src/main/org/openscience/cdk/smsd/core/tools/EBIException.java
@@ -28,27 +28,27 @@ package org.openscience.cdk.smsd.core.tools;
 /**
  * @cdk.module smsd
  */
-public class EBIException extends Exception {
+public class CDKException extends Exception {
 
     private static final long serialVersionUID = 8371328769230823678L;
 
     /**
-     * Constructs a new EBIException with the given message.
+     * Constructs a new CDKException with the given message.
      *
      * @param message for the constructed exception
      */
-    public EBIException(String message) {
+    public CDKException(String message) {
         super(message);
     }
 
     /**
-     * Constructs a new EBIException with the given message and the
+     * Constructs a new CDKException with the given message and the
      * Exception as cause.
      *
      * @param message for the constructed exception
-     * @param cause   the Throwable that triggered this EBIException
+     * @param cause   the Throwable that triggered this CDKException
      */
-    public EBIException(String message, Throwable cause) {
+    public CDKException(String message, Throwable cause) {
         super(message, cause);
     }
 }
diff --git a/src/main/org/openscience/cdk/smsd/core/tools/MoleculeSanityCheck.java b/src/main/org/openscience/cdk/smsd/core/tools/MoleculeSanityCheck.java
index 6354cde..dae5f34 100644
--- a/src/main/org/openscience/cdk/smsd/core/tools/MoleculeSanityCheck.java
+++ b/src/main/org/openscience/cdk/smsd/core/tools/MoleculeSanityCheck.java
@@ -86,7 +86,7 @@ public class MoleculeSanityCheck {
 //        try {
 //            CDKHueckelAromaticityDetector.detectAromaticity(molecule);
 //        } catch (CDKException e) {
-//            throw new EBIException("Error in aromaticity detection");
+//            throw new CDKException("Error in aromaticity detection");
 //        }
 
         return molecule;
diff --git a/src/main/org/openscience/cdk/smsd/factory/MCSFactory.java b/src/main/org/openscience/cdk/smsd/factory/MCSFactory.java
index 2f79bac..bdc1846 100644
--- a/src/main/org/openscience/cdk/smsd/factory/MCSFactory.java
+++ b/src/main/org/openscience/cdk/smsd/factory/MCSFactory.java
@@ -4,7 +4,7 @@
  */
 package org.openscience.cdk.smsd.factory;
 
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.interfaces.IMCS;
 import org.openscience.cdk.smsd.interfaces.IMCSAlgorithm;
 import org.openscience.cdk.smsd.interfaces.IMCSBase;
@@ -468,7 +468,7 @@ public class MCSFactory implements IMCSAlgorithm {
 
         } catch (IOException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
 
@@ -495,7 +495,7 @@ public class MCSFactory implements IMCSAlgorithm {
 
         } catch (IOException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
 
@@ -517,7 +517,7 @@ public class MCSFactory implements IMCSAlgorithm {
 
             MCSBuilder();
             setChemFilters();
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(SubGraphFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
@@ -555,7 +555,7 @@ public class MCSFactory implements IMCSAlgorithm {
 
     }
 
-    public synchronized void setChemFilters() throws EBIException {
+    public synchronized void setChemFilters() throws CDKException {
         if (firstAtomMCS != null) {
             ChemicalFilters CF = new ChemicalFilters(allMCS, allAtomMCS, firstSolution, firstAtomMCS, RMol, PMol);
 
@@ -686,8 +686,8 @@ public class MCSFactory implements IMCSAlgorithm {
             return allAtomMCS;
         } else {
             try {
-                throw new EBIException("No Solutions!");
-            } catch (EBIException ex) {
+                throw new CDKException("No Solutions!");
+            } catch (CDKException ex) {
                 Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
             }
             return null;
@@ -925,7 +925,7 @@ public class MCSFactory implements IMCSAlgorithm {
 
         } catch (IOException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
 
@@ -954,7 +954,7 @@ public class MCSFactory implements IMCSAlgorithm {
 
         } catch (IOException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
diff --git a/src/main/org/openscience/cdk/smsd/factory/SubGraphFactory.java b/src/main/org/openscience/cdk/smsd/factory/SubGraphFactory.java
index 2c200dc..19b2461 100644
--- a/src/main/org/openscience/cdk/smsd/factory/SubGraphFactory.java
+++ b/src/main/org/openscience/cdk/smsd/factory/SubGraphFactory.java
@@ -15,7 +15,7 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import org.openscience.cdk.smsd.algorithm.single.SingleMappingHandler;
 import org.openscience.cdk.smsd.algorithm.vflib.VFlibTurboHandler;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.filters.ChemicalFilters;
 import org.openscience.cdk.smsd.global.BondType;
 import org.openscience.cdk.smsd.global.TimeOut;
@@ -147,7 +147,7 @@ public class SubGraphFactory implements IMCSAlgorithm {
 
             MCSBuilder();
             setChemFilters();
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(SubGraphFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
@@ -185,7 +185,7 @@ public class SubGraphFactory implements IMCSAlgorithm {
 
     }
 
-    public synchronized void setChemFilters() throws EBIException {
+    public synchronized void setChemFilters() throws CDKException {
         if (firstAtomMCS != null) {
             ChemicalFilters CF = new ChemicalFilters(allMCS, allAtomMCS, firstSolution, firstAtomMCS, RMol, PMol);
 
@@ -539,7 +539,7 @@ public class SubGraphFactory implements IMCSAlgorithm {
 
         } catch (IOException ex) {
             Logger.getLogger(SubGraphFactory.class.getName()).log(Level.SEVERE, null, ex);
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(SubGraphFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
 
@@ -569,7 +569,7 @@ public class SubGraphFactory implements IMCSAlgorithm {
 
         } catch (IOException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
diff --git a/src/main/org/openscience/cdk/smsd/filters/ChemicalFilters.java b/src/main/org/openscience/cdk/smsd/filters/ChemicalFilters.java
index 4507cd0..51a2c3d 100644
--- a/src/main/org/openscience/cdk/smsd/filters/ChemicalFilters.java
+++ b/src/main/org/openscience/cdk/smsd/filters/ChemicalFilters.java
@@ -16,7 +16,7 @@ import java.util.Vector;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import org.openscience.cdk.smsd.core.tools.EBIBondEnergies;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.CDKConstants;
 import org.openscience.cdk.DefaultChemObjectBuilder;
@@ -577,7 +577,7 @@ public class ChemicalFilters {
 
     }
 
-    private synchronized Double getMappedMoleculeEnergies(TreeMap<Integer, Integer> MCSAtomSolution) throws EBIException {
+    private synchronized Double getMappedMoleculeEnergies(TreeMap<Integer, Integer> MCSAtomSolution) throws CDKException {
 
 //        System.out.println("\nSort By Energies");
         EBIBondEnergies bE = EBIBondEnergies.getInstance();
@@ -659,7 +659,7 @@ public class ChemicalFilters {
         return totalBondEnergy;
     }
 
-    public synchronized void sortResultsByEnergies() throws EBIException {
+    public synchronized void sortResultsByEnergies() throws CDKException {
 
 //        System.out.println("\nSort By Energies");
         Map<Integer, TreeMap<Integer, Integer>> allEnergyMCS = new TreeMap<Integer, TreeMap<Integer, Integer>>();
diff --git a/src/main/org/openscience/cdk/smsd/filters/FragmentMatcher.java b/src/main/org/openscience/cdk/smsd/filters/FragmentMatcher.java
index 8b02927..f1fc5b3 100644
--- a/src/main/org/openscience/cdk/smsd/filters/FragmentMatcher.java
+++ b/src/main/org/openscience/cdk/smsd/filters/FragmentMatcher.java
@@ -40,7 +40,7 @@ import org.openscience.cdk.smsd.algorithm.cdk.CDKMCSHandler;
 import org.openscience.cdk.smsd.algorithm.mcsplus.MCSPlusHandler;
 import org.openscience.cdk.smsd.algorithm.single.SingleMappingHandler;
 import org.openscience.cdk.smsd.algorithm.vflib.VFlibMCSHandler;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.factory.MCSFactory;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.smsd.interfaces.IFragment;
@@ -283,7 +283,7 @@ public class FragmentMatcher implements IFragment {
             allAtomMCS = mcs.getAllAtomMapping();
             atomsMCS = mcs.getFirstAtomMapping();
 
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
 
@@ -319,7 +319,7 @@ public class FragmentMatcher implements IFragment {
 
         } catch (IOException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
 
@@ -372,7 +372,7 @@ public class FragmentMatcher implements IFragment {
 
         } catch (IOException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
-        } catch (EBIException ex) {
+        } catch (CDKException ex) {
             Logger.getLogger(MCSFactory.class.getName()).log(Level.SEVERE, null, ex);
         }
     }
diff --git a/src/main/org/openscience/cdk/smsd/interfaces/IMCS.java b/src/main/org/openscience/cdk/smsd/interfaces/IMCS.java
index 090c990..d74558f 100644
--- a/src/main/org/openscience/cdk/smsd/interfaces/IMCS.java
+++ b/src/main/org/openscience/cdk/smsd/interfaces/IMCS.java
@@ -27,7 +27,7 @@ package org.openscience.cdk.smsd.interfaces;
 
 
 import java.io.IOException;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.interfaces.IAtomContainer;
 
@@ -43,9 +43,9 @@ public interface IMCS extends IMCSBase {
      * @param removeHydrogen 
      * @return
      * @throws java.io.IOException
-     * @throws EBIException
+     * @throws CDKException
      */
-    int search_MCS(boolean removeHydrogen) throws IOException, EBIException;
+    int search_MCS(boolean removeHydrogen) throws IOException, CDKException;
 
     /**
      * Creates a new instance of SearchCliques
diff --git a/src/main/org/openscience/cdk/smsd/interfaces/IMCSAlgorithm.java b/src/main/org/openscience/cdk/smsd/interfaces/IMCSAlgorithm.java
index 7b8f5a1..bb0d85c 100644
--- a/src/main/org/openscience/cdk/smsd/interfaces/IMCSAlgorithm.java
+++ b/src/main/org/openscience/cdk/smsd/interfaces/IMCSAlgorithm.java
@@ -23,7 +23,7 @@
 package org.openscience.cdk.smsd.interfaces;
 
 import java.io.IOException;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.interfaces.IAtomContainer;
 import org.openscience.cdk.interfaces.IMolecule;
@@ -57,9 +57,9 @@ public interface IMCSAlgorithm extends IMCSBase {
 //     * @param Product
 //     * @param ReactantFingerprint
 //     * @param ProductFingerprint
-//     * @throws EBIException
+//     * @throws CDKException
 //     */
-//    void init(IMolecule Reactant, IMolecule Product, BitSet ReactantFingerprint, BitSet ProductFingerprint)throws EBIException;
+//    void init(IMolecule Reactant, IMolecule Product, BitSet ReactantFingerprint, BitSet ProductFingerprint)throws CDKException;
 //
 //    /**
 //     *
@@ -67,9 +67,9 @@ public interface IMCSAlgorithm extends IMCSBase {
 //     * @param Product
 //     * @param ReactantFingerprint
 //     * @param ProductFingerprint
-//     * @throws EBIException
+//     * @throws CDKException
 //     */
-//    void init(IAtomContainer Reactant, IAtomContainer Product, BitSet ReactantFingerprint, BitSet ProductFingerprint)throws EBIException;
+//    void init(IAtomContainer Reactant, IAtomContainer Product, BitSet ReactantFingerprint, BitSet ProductFingerprint)throws CDKException;
 //
 //    /**
 //     *
@@ -77,31 +77,31 @@ public interface IMCSAlgorithm extends IMCSBase {
 //     * @param Product
 //     * @param ReactantFingerprint
 //     * @param ProductFingerprint
-//     * @throws EBIException
+//     * @throws CDKException
 //     */
-//    void init(MolHandler Reactant, MolHandler Product, BitSet ReactantFingerprint, BitSet ProductFingerprint)throws EBIException;
+//    void init(MolHandler Reactant, MolHandler Product, BitSet ReactantFingerprint, BitSet ProductFingerprint)throws CDKException;
     /**
      *
      * @param Reactant
      * @param Product
-     * @throws EBIException 
+     * @throws CDKException
      *
      */
-    void init(MolHandler Reactant, MolHandler Product) throws EBIException;
+    void init(MolHandler Reactant, MolHandler Product) throws CDKException;
 
     /**
      *
      * @param Reactant
      * @param Product
-     * @throws EBIException 
+     * @throws CDKException
      */
-    void init(IMolecule Reactant, IMolecule Product) throws EBIException;
+    void init(IMolecule Reactant, IMolecule Product) throws CDKException;
 
     /**
      *
      * @param Reactant
      * @param Product
-     * @throws EBIException 
+     * @throws CDKException
      */
-    void init(IAtomContainer Reactant, IAtomContainer Product) throws EBIException;
+    void init(IAtomContainer Reactant, IAtomContainer Product) throws CDKException;
 }
diff --git a/src/main/org/openscience/cdk/smsd/interfaces/ISubGraph.java b/src/main/org/openscience/cdk/smsd/interfaces/ISubGraph.java
index 4572427..118ced3 100644
--- a/src/main/org/openscience/cdk/smsd/interfaces/ISubGraph.java
+++ b/src/main/org/openscience/cdk/smsd/interfaces/ISubGraph.java
@@ -23,7 +23,7 @@
 package org.openscience.cdk.smsd.interfaces;
 
 import java.io.IOException;
-import org.openscience.cdk.smsd.core.tools.EBIException;
+import org.openscience.cdk.smsd.core.tools.CDKException;
 import org.openscience.cdk.smsd.helper.MolHandler;
 import org.openscience.cdk.interfaces.IAtomContainer;
 
@@ -37,9 +37,9 @@ public interface ISubGraph extends IMCSBase {
      * @return true if Query/Reactant is a subgraph of Target/Product
      * else false
      * @throws java.io.IOException
-     * @throws EBIException 
+     * @throws CDKException
      */
-    boolean isSubgraph() throws IOException, EBIException;
+    boolean isSubgraph() throws IOException, CDKException;
 
     /**
      * Creates a new instance of SearchCliques
-- 
1.6.1.2

